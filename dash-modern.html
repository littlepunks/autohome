<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html">
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script> <!-- Include Socket.io -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
Â    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Autohome</title>
  <link rel="stylesheet" href="styles.css">
</head> <!-- ***** MUST REMOVE PATH WHEN USING LIVE ****-->
<body>

<ul class="menu" id="menubar">
   <li><a onclick="handleItemClick('Home')">Home</a></li>
    
  <li class="dropdown">
    <a href="http://192.168.68.72/autohome.html#" class="dropbtn">Other</a>
    <div class="dropdown-content" style="display: none;">
      <a onclick="handleItemClick('Graphs')">Graphs</a>
      <a href="http://192.168.68.72/autohome.html#">Mobile</a>
      <a href="http://192.168.68.72/autohome.html#">UI/UX</a>
    </div>
  </li>
  
  <li class="dropdown">
    <a class="dropbtn">Services</a>
    <div class="dropdown-content" style="display: none;">
      <a onclick="handleItemClick('Web')">Web</a>
      <a href="http://192.168.68.72/autohome.html#">Mobile App Development</a>
      <a href="http://192.168.68.72/autohome.html#">UI/UX Design</a>
    </div>
  </li>
  
  <li>
    <a id="Dev">Settings</a>
    <div class="dropdown-content">
      <a onclick="handleItemClick('Grid Code')">Grid Code</a>
      <a onclick="handleItemClick('Toggle Grid')">Toggle Grid</a>
      <a onclick="handleItemClick('Show All Items')">Show All Items</a>
    </div>

  </li>
</ul>
<div class="canvas-container">
  <canvas id="mainCanvas" width="150" height="754"></canvas>
</div>
<div id="contextMenu" class="context-menu" style="left: 444px; top: 518px; display: block;">
  <ul>
      <li onclick="handleContextMenuClick('Hide')">Hide</li>
      <li onclick="handleContextMenuClick('Something')">Something</li>
      <li onclick="handleContextMenuClick('Else')">Else</li>
  </ul>
</div>

<script>

// ============================================================================================
//
// To do:
// - Ideally when dragging a control the rest of the screen shows other controls
// - When dragging target area should show a highlight
// - Add switches, status, plain numbers, text, clock, alarm
// - change language to 'controls'
// - Better classes and values including (x,y) (r,c)
// - Different size tiles
// - When dragging bars, they move as gauges (?!), need common draw gauge function
// - Change hard coded numbers like padding in pixels to ratios
// - Doesn't resize properly when windows is very wide
// - When resizing window the whole dash scales weirdly until you stop and do a proper refresh
// ============================================================================================



// Menu event handlers

document.body.addEventListener("mouseover", (event) => {
   const dropdown = event.target.closest(".dropdown");
   if (dropdown) {
      dropdown.querySelector(".dropdown-content").style.display = "block";
   }
});

document.body.addEventListener("mouseout", (event) => {
   const dropdown = event.target.closest(".dropdown");
   if (dropdown) {
      dropdown.querySelector(".dropdown-content").style.display = "none";
   }
});

// Get the canvas element and its 2D context, and the context menu
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const contextMenu = document.getElementById('contextMenu');
contextMenu.style.display = 'none'; // Hide the context menu after clicking

// Set height to be full screen minus the height of the menu
let menuObj = document.getElementById('menubar');
canvas.height = window.innerHeight - menuObj.offsetHeight-10;
canvas.width = (window.innerWidth > 500) ? 500 : window.innerWidth  ;

// Set up canvas style settings
ctx.shadowColor = 'rgba(0, 0, 20, 0.5)';  // Shadow color with transparency
ctx.shadowBlur = 10;                      // Shadow blur radius
ctx.shadowOffsetX = 5;                    // Horizontal shadow offset
ctx.shadowOffsetY = 5;                    // Vertical shadow offset

const colGaugeBkgnd = '#907010';          // Dark orange/yellow
const colGaugeColor = '#d0b020';          // Light orange/yellow
const colGrid       = '#808080';          // Medium grey
const colBackground = '#204060';          // Medium blue

let showGrid = true;

const PI  = Math.PI;
const PI2 = 2 * Math.PI;

// Used for detecting touch events (right click) on a mobile device
let touchTimer = null;

// Grid settings
const cols = 4;
const rows = 5;
let margin = canvas.width /(cols*2);   // margin is half the column width
let colWidth = canvas.width / cols;
const rowHeight = canvas.height / rows; // Will this need adjusting on resize?

// Top left item is at 0,0
// colWidth = 125 

// Convert an X or Y coordinate to a row or column
function xy2rc(xy) {
  return (xy < 0) ? 1 : (Math.floor(xy/colWidth) + 1);
}

// Convert a row or column to an X or Y coordinate
function rc2xy(rc) {
  return (rc <= 0) ? 0 : ((rc-1) * colWidth);
}

// Connect to the Socket.io server
const socket = io();

// Process a sensor message from the server
socket.on('SMv2', (arg) => {
  const msg = typeof arg === 'string' ? JSON.parse(arg) : arg;

  // Update the sensor value
  updateSensor(msg.name, msg.value);
  // Update charts
  updateChartFromJSON(msg);
  // Redraw the dashboard
  drawDash();

  console.log(`Sensor: ${msg.name}, Value: ${msg.value}, Updated: ${epochToISO(msg.updated)}`); 
  }
);

// Update display info:
function updateSensor(name, value) {
  for (let item of dash) {
      if (item.name === name) {
        item.value = value;

        // -----------------
        // Eventually move to scheduled pulls of graph data from the controller
        // but in the mean time add data to the graph object

        // -----------------
        break; // Stop the loop once the name is found
      }
  }
}

let dash = []; // Initialize the dash array

// Global Chart.js objects
let temperatureGraph;
let temperatureChartData = {
  labels: [],
  datasets: []
};

drawInitialChart(); // Call once to start

// Request an initial sensor list from the server
socket.emit('ClientMsg', 'init');

// Process the initial sensor list from the server
socket.on('sensors', (arg) => {
  dash = JSON.parse(arg);
  dash.forEach(obj => {  //Set some initial values that are client specific
    updateChartFromJSON(obj); // Add to chart data
  
    obj.x = 0;
    obj.y = 0;
    obj.col = 0
    obj.row = 0;
    obj.enabled = false;
    obj.min ??= 0; // Default min to 0 if not provided
    obj.max ??= 0;
    obj.suffix ??= ''; // Default suffix to empty string if not provided    
  });
  //console.log(dash);

  // Update display info:
  function updateSensorLocation(data, name, col, row, enabled) {
    for (let item of data) {
        if (item.name === name) {
          item.col = col;
          item.row = row;
          item.enabled = enabled;
          item.x = (item.col-1) * colWidth;
          item.y = (item.row-1) * colWidth;

          break; // Stop the loop once the name is found
        }
    }
  }

  // Set the initial locations of the sensors
  updateSensorLocation(dash, 'Bedroom', 1, 1, true);
  updateSensorLocation(dash, 'Balcony', 2, 1, true);
  updateSensorLocation(dash, 'Freezer', 3, 1, true);
  updateSensorLocation(dash, 'Laundry', 4, 1, true);

  updateSensorLocation(dash, 'Tom', 1, 2, true);
  updateSensorLocation(dash, 'Speed', 2, 2, true);
  updateSensorLocation(dash, 'Humidity', 3, 2, true);
  updateSensorLocation(dash, 'Pressure', 4, 2, true);

  updateSensorLocation(dash, 'Sunrise', 1, 3, true);
  updateSensorLocation(dash, 'Sunset', 2, 3, true);
  updateSensorLocation(dash, 'Web Temp', 3, 3, true);
  
  updateSensorLocation(dash, 'W Desc', 1, 4, true);
  updateSensorLocation(dash, 'W Main', 2, 4, true);
  updateSensorLocation(dash, 'Hall', 3, 4, true);
  updateSensorLocation(dash, 'Door', 4, 4, true);

  drawDash();

});

// Draw Graphs ****************

  // [ NOT IN USE ] Functon below should be able to parse RRTOOL extract data into a graphable format
  //---------------
function parseLabeledData(input) {
  // Split the input text into individual lines, removing any leading/trailing whitespace
  const lines = input.trim().split('\n');

  // Extract the first line which contains the column headers
  // We skip the first column (timestamp) and keep the rest as data column names
  const headers = lines[0].trim().split(/\s+/).slice(1);

  // Initialize the result object with:
  // - 'labels': an array to store formatted time strings (hh:mm)
  // - 'datasets': an array of objects, each representing a data column with a label and data array
  const result = {
    labels: [],
    datasets: headers.map(header => ({
      label: header, // Name of the data column
      data: []       // Array to store the values for this column
    }))
  };

  // Loop through each line of data, starting from the second line (index 1)
  for (let i = 1; i < lines.length; i++) {
    // Remove the colon after the timestamp and split the line into parts
    const parts = lines[i].replace(':', '').trim().split(/\s+/);

    // Parse the first part as a Unix timestamp (in seconds)
    const timestamp = parseInt(parts[0], 10);

    // Convert the Unix timestamp to a JavaScript Date object
    const date = new Date(timestamp * 1000); // Multiply by 1000 to convert to milliseconds

    // Format the time as "hh:mm" using ISO string slicing
    const hhmm = date.toISOString().substr(11, 5);

    // Add the formatted time to the 'labels' array
    result.labels.push(hhmm);

    // Loop through the remaining parts (data values)
    parts.slice(1).forEach((val, index) => {
      // Convert the string to a floating-point number
      const num = parseFloat(val);

      // Add the number to the corresponding dataset's data array
      result.datasets[index].data.push(num);
    });
  }

  // Return the fully constructed result object
  return result;
}

// ==========================================================================
// Graphing/Charting
// Using chart.js module
// ==========================================================================

// An array of colors for the datasets
// They are consumed in order as datasets are added
const dataColors = [
  'rgba(255, 0, 0, 0.5)',
  'rgba(0, 255, 0, 0.5)',
  'rgba(0, 0, 255, 0.5)',

  'rgba(128, 128, 0, 0.5)',
  'rgba(0, 128, 128, 0.5)',
  'rgba(224, 0, 224, 0.5)',

  'rgba(255, 128, 0, 0.5)',
  'rgba(0, 255, 128, 0.5)',
  'rgba(128, 0, 255, 0.5)'
];

// Get canvas and set background colour
function initChartCanvas() {
  const ctx = document.getElementById('mainCanvas');
  ctx.style.backgroundColor = colBackground;
  return ctx;
}

// ISO label conversion helper (optional)
function epochToISO(epochMs) {
  return new Date(epochMs).toISOString();
}

// Adds a full dataset
function addChartDataset(label, data) {
  temperatureChartData.datasets.push({ label, data, tension: 0.4 });
}

// Adds a new data point to an existing dataset (or creates one)
function addChartDataPoint(sensorLabel, isoTime, value) {
  // Add a timestamp if it doesn't already exist (x axis)
  if (!temperatureChartData.labels.includes(isoTime)) {
    temperatureChartData.labels.push(isoTime);
  }

  // See if any existing dataset exists for the current sensor label
  let dataset = temperatureChartData.datasets.find(ds => ds.label === sensorLabel);
  if (!dataset) {
    // Build a new dataset if it doesn't exist
    dataset = {
      label: sensorLabel,
      data: [],
      backgroundColor: dataColors[temperatureChartData.datasets.length],
      borderColor: dataColors[temperatureChartData.datasets.length],
      tension: 0.4
    };

    // Add it to the chart data
    temperatureChartData.datasets.push(dataset);
  }

  dataset.data.push(value);
}

// Update chart from incoming JSON object
function updateChartFromJSON(jsonObj) {
  const { name, value, updated, control } = jsonObj;

  const includeList = ['Bedroom', 'Balcony', 'Freezer', 'Laundry', 'Tom', 'Web Temp', 'Feels Like'];
  const timeISO = epochToISO(updated);
  let numericValue = parseFloat(value);

  if (isNaN(numericValue) || !includeList.includes(name) || (control != 'GAU')) {
    // The small weather icon controls are examples where value
    // is not a number so they can be safely skipped
    return;
  }

  // Otherwise, add the data point to the chart
  addChartDataPoint(name, timeISO, numericValue);

  if (temperatureGraph) temperatureGraph.update();
}

// Chart configuration and instantiation
function drawInitialChart() {
  const ctx = initChartCanvas();

  const temperatureChartConfig = {
    type: 'line',
    data: temperatureChartData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { left: 10, right: 10 }
      },
      plugins: {
        legend: {
          position: 'bottom',
          labels: { boxWidth: 10 }
        },
        title: {
          display: true,
          text: 'Temperatures',
          font: { size: 30 }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            parser: 'YYYY-MM-DDTHH:mm:ss.SSSZ',
            tooltipFormat: 'HH:mm',
            displayFormats: { minute: 'HH:mm' }
          }
        },
        y: {
          grid: { color: '#505050' }
        }
      }
    }
  };

  Chart.defaults.color = 'lightgray';
  Chart.defaults.font.size = 18;

  // If a chart instance doesn't exist on the canvas create a new one
  temperatureGraph = Chart.getChart(ctx);
  if (!temperatureGraph) {
      temperatureGraph = new Chart(ctx, temperatureChartConfig);
  } else {
    temperatureGraph.update();
  }
}


// Helper functions
// ----------------------------------------------------------------------
// Draw grid
function drawGrid() {
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;

    ctx.strokeStyle = colGrid;
    ctx.lineWidth = 1;
    ctx.beginPath()

    // Draw vertical lines
    for (let i=1; i < cols; i++) {
        ctx.moveTo(colWidth*i,0);
        ctx.lineTo(colWidth*i,canvas.height);
    }

    // Draw horizontal lines
    for (let j=1; j < rows; j++) {
        ctx.moveTo(0, colWidth*j);
        ctx.lineTo(canvas.width, colWidth*j);
    }
    ctx.stroke();

    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;
    ctx.shadowBlur = 10;
}

// Draw all dash controls and the grid
function drawDash() {
  // Deleteme later ....
return;

  setBackgroundColor(colBackground);

  // Not 100% this is needed?
  const isChart = document.getElementById('mainCanvas');
  if (isChart) {
    chartsCtx = isChart.getContext('2d');
    //isChart.style.display = 'none';
  }

  if (showGrid) drawGrid;

  dash.forEach(obj => {
    if (obj.enabled) drawDashObj(obj);
  })
}

// Need to add MAX/MIN to the settings for gauges
function drawDashObj(dashObj, overrides = {}) {
  if (!dashObj.enabled) return;

  const drawFunctions = {
    'GAU': drawGauge,
    'STA': drawStatus,
    'bar-v': drawBarV,
    'bar-h': drawBarH
    }
  const drawFunction = drawFunctions[dashObj.control];
  if (drawFunction) {

    if (overrides.shadow) {
      ctx.shadowColor = 'rgba(0, 0, 0, 1)';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 10;
      ctx.shadowOffsetY = 10;
    } else {
      ctx.shadowColor = 'rgba(0, 0, 20, 0.5)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 5;
      ctx.shadowOffsetY = 5;
    }
    drawFunction(dashObj, overrides);
    }
}

// DRAW GAUGE

function drawGauge(g, opts) {
  const thickness = 14; // Bigger numbers make it thinner

  // Determine X/Y coordinates
  let cx = opts?.x ?? margin + (g.col - 1) * colWidth;
  let cy = opts?.y ?? margin + (g.row - 1) * colWidth;

  if (opts && Object.keys(opts).length > 0 && showGrid) {
      drawGrid();
  }

  // Determine fill color based on contact_status
  const colorMap = {
      1: "darkorange",
      2: "red"
  };
  const fillColor = colorMap[g.contact_status] || "darkgreen";
  drawArc(cx, cy, canvas.width / (cols * 2.8), fillColor);

  // Draw gauge background
  drawArc(cx, cy, canvas.width / (cols * 2.6), colGaugeBkgnd, true, canvas.width / (thickness * cols));

  // Draw gauge value arc
  const angle = (2 * (g.value - g.min) / (g.max - g.min)) * Math.PI;
  ctx.beginPath();
  ctx.arc(cx, cy, canvas.width / (cols * 2.6), -Math.PI / 2, -Math.PI / 2 + angle);
  ctx.strokeStyle = colGaugeColor;
  ctx.lineWidth = canvas.width / (thickness * cols);
  ctx.stroke();

  // Draw labels
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${canvas.width / (11 * cols)}px Arial`;
  ctx.fillText(g.name, cx, cy - margin * 0.3);

  // Scale font size dynamically based on text length
  const gaugeText = `${g.value}${g.suffix ?? ''}`;
  ctx.font = `${Math.max(12, canvas.width / (cols * (gaugeText.length * 5)))}px Arial`;

  // Set the text color based on alarm state
  ctx.fillStyle = g.alarmState === 1 ? 'orange' : g.alarmState === 2 ? 'red' : 'white';
  ctx.fillText(gaugeText, cx, cy + margin * 0.25);
}


function drawArc(x, y, radius, style, isStroke = false, lineWidth = 1) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    if (isStroke) {
        ctx.strokeStyle = style;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
    } else {
        ctx.fillStyle = style;
        ctx.fill();
    }
}

// DRAW STATUS
function drawStatus(g, opts) {
    const thickness = 14; // Bigger numbers make it thinner

    // See if x/y coords are included and if so, respect those, otherwise x/y will be based on col/row as normal
    let cx = 0;
    let cy = 0;

    if (opts && Object.keys(opts).length > 0 && showGrid) {
        drawGrid();
    }
    cx = opts?.x ?? margin + (g.col - 1) * colWidth;
    cy = opts?.y ?? margin + (g.row - 1) * colWidth;

    // Determine the fill color based on contact_status
    // Draw orange/red background if in alarm states 1 or 2 (0 is no alarm)
    const colorMap = {
      1: "darkorange",
      2: "red"
    };
    const fillColor = colorMap[g.contact_status] || "darkgreen";

    drawArc(cx, cy, canvas.width / (cols * 2.8), fillColor);
    drawArc(cx, cy, canvas.width / (cols * 2.6), colGaugeBkgnd, true, canvas.width / (thickness * cols));
    drawArc(cx, cy + margin * 0.25, canvas.width / (cols * 6), colGaugeColor, true, canvas.width / (thickness * cols * 1.8));
    drawArc(cx, cy + margin * 0.25, canvas.width / (cols * 8), g.status == '1' ? 'green' : 'red');

    // Draw labels
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.font = `${canvas.width / (11 * cols)}px Arial`;
    ctx.fillText(g.name, cx, cy - margin * 0.3);

}

// Function to simplify line drawing
function drawLine(x1, y1, x2, y2, style, width) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = style;
    ctx.lineWidth = width;
    ctx.stroke();
}

function drawBarV(b, opts) {
    // Determine X/Y coordinates
    let bx = opts?.x ?? margin + (b.col - 1) * colWidth;
    let by = opts?.y ?? margin + (b.row - 1) * colWidth;

    if (opts && Object.keys(opts).length > 0 && showGrid) {
        drawGrid();
    }

    // Draw bar background
    const lineWidth = canvas.width / (8 * cols);
    drawLine(bx, by - (0.8 * margin), bx, by + (0.8 * margin), colGaugeBkgnd, lineWidth);

    // Draw bar value
    const valueHeight = (0.8 * colWidth * (b.value - b.min) / (b.max - b.min));
    drawLine(bx, by + (0.8 * margin), bx, by + (0.8 * margin) - valueHeight, colGaugeColor, lineWidth);

    // Draw labels - value, max, and min
    ctx.font = `${canvas.width / (6 * cols)}px Arial`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'right';
    ctx.fillText(b.value, bx - 15, by + 8);

    ctx.font = `${canvas.width / (12 * cols)}px Arial`;
    ctx.textAlign = 'left';
    ctx.fillText(b.max, bx + 15, by - (0.8 * margin) + 10);
    ctx.fillText(b.min, bx + 15, by + (0.8 * margin) - 2);
}

function drawBarH(b, opts) {
    // Determine X/Y coordinates
    let bx = opts?.x ?? margin + (b.col - 1) * colWidth;
    let by = opts?.y ?? margin + (b.row - 1) * colWidth;

    if (opts && Object.keys(opts).length > 0 && showGrid) {
        drawGrid();
    }

    // Draw bar background
    const lineWidth = canvas.width / (8 * cols);
    drawLine(bx - (0.8 * margin), by, bx + (0.8 * margin), by, colGaugeBkgnd, lineWidth);

    // Draw bar value
    const valueWidth = (0.8 * colWidth * (b.value - b.min) / (b.max - b.min));
    drawLine(bx - (0.8 * margin), by, bx - (0.8 * margin) + valueWidth, by, colGaugeColor, lineWidth);

    // Draw labels - value, min, and max
    ctx.font = `${canvas.width / (6 * cols)}px Arial`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(b.value, bx, by - 18);

    ctx.font = `${canvas.width / (12 * cols)}px Arial`;
    ctx.textAlign = 'left';
    ctx.fillText(b.min, bx - (0.8 * margin), by + 22);
    ctx.textAlign = 'right';
    ctx.fillText(b.max, bx + (0.8 * margin), by + 22);
}


// Change the canvas background color
function setBackgroundColor(color) {
    // Save the current transformation matrix
    ctx.save();

    // Reset the canvas transformation matrix
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Restore the saved transformation matrix
    ctx.restore();

    // Set the new background color
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// Toggle menu item visibility
function toggleMenuItem(itemId) {
    var item = document.getElementById(itemId);
    if (item) {
      item.style.display = (item.style.display == 'none') ? 'block' : 'none';
    }
}

// Set menu item visibility
function set(itemId, show) {
    var item = document.getElementById(itemId);
    if (item) {
        item.style.display = show ? 'block' : 'none';
    }
}


// Draw everything
drawDash();
let resizeTimer = null; // Timer for resize event debouncing
window.addEventListener('resize', () => {
    clearTimeout(resizeTimer); // Clear the previous timer
    resizeTimer = setTimeout(() => {
        // Resize the canvas and redraw
        canvas.height = window.innerHeight - menuObj.offsetHeight;
        canvas.width = Math.min(window.innerWidth, 500);

        //const menu = document.querySelector('.menu');

        // Ensure the canvas is positioned absolutely
        //canvas.style.position = 'absolute';

        // Set the top position of the canvas to the bottom of the menu
        //canvas.style.top = menu.offsetHeight*20 + 'px';

        
        margin = canvas.width /(cols*2);   // margin is half the column width

        colWidth = canvas.width/cols; // How far apart cells are   500 wide / 4 cols = 125 pxls
        // canvas.style.width = window.innerWidth;
        // canvas.style.height = window.innerHeight;
        
        // Optionally, redraw your canvas content here
        //setBackgroundColor(colBackground);
        drawDash();
        temperatureGraph.resize();
    }, 200); // Adjust the delay as needed (e.g., 100ms)

});

canvas.addEventListener("click", (event) => {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const col = Math.floor(x / colWidth) + 1;
    const row = Math.floor(y / rowHeight) + 1;
    //console.log(`Clicked at Row: ${row}, Column: ${col}`);

    // Check if a sensor exists at the clicked location
    const ctrl = dash.find(obj => obj.col === col && obj.row === row);

    if (ctrl) {

      function formattimeStamp(timeStamp) {
        const date = new Date(timeStamp); //
        return date.toLocaleString('en-NZ'); // Returns a formatted date/time
      }

      // console.log(`Clicked on sensor: ${ctrl.name} (Row: ${row}, Column: ${col})`);
      // Show popup
      const popup = document.createElement("div");
      popup.innerText =
       `ID: ${ctrl.id}
        Name: ${ctrl.name}
        Value: ${ctrl.value}${ctrl.suffix ?? ''}
        Contact Status: ${ctrl.contact_status === '0' ? 'OK (0)' : ctrl.contact_status === '1' ? 'Late (1)' :  ctrl.contact_status === '2' ? 'Missing (2)' : 'Undefined'}
        Last Contact: ${formattimeStamp(ctrl.updated)}
        AlarmState: ${ctrl.alarmState}
        Min: ${ctrl.min}
        Max: ${ctrl.max}
        Warning Threshold: ${ctrl.warningThreshold}
        Alarm Threshold: ${ctrl.alarmThreshold}
        Col: ${ctrl.col}
        Row: ${ctrl.row}
        Enabled: ${ctrl.enabled}
        Control Type: ${ctrl.control}`;
      popup.style.position = "absolute";
      popup.style.backgroundColor = "rgba(0,0,10,0.9)";
      popup.style.color = "white";
      popup.style.border = "1px solid white";
      popup.style.padding = "10px";
      popup.style.zIndex = "1000";
      popup.style.top = `${event.clientY}px`;
      popup.style.left = `${event.clientX}px`;
      popup.style.fontSize = "12px";
      document.body.appendChild(popup);

      // Remove popup after a delay
      setTimeout(() => {
          popup.remove();
      }, 10000);
    } else {
      //console.log(`Clicked on blank space (Row: ${row}, Column: ${col})`);
    }


});

// ---------------------------------------------------------------------------
//let selectedObject = null;
let offsetX, offsetY;
//let clickX, clickY;

//         // Show popup
//         const popup = document.createElement("div");
//         popup.innerText = `Control: ${controlNameOrNumber}`;
//         popup.style.position = "absolute";
//         popup.style.backgroundColor = "rgba(0,0,0,0.7)";
//         popup.style.color = "white";
//         popup.style.border = "1px solid white";
//         popup.style.padding = "10px";
//         popup.style.zIndex = "1000";
//         popup.style.top = `${event.clientY}px`;
//         popup.style.left = `${event.clientX}px`;
//         document.body.appendChild(popup);

//         // Remove popup after a delay
//         setTimeout(() => {
//             popup.remove();
//         }, 2000);
//     }
// });

// Menu item click handler
// This function is called when a menu item is clicked
function handleItemClick(item) {
    if (!item) return;

    switch (item) {
        case "Web":
            window.alert("You are doing the Web");
            break;

        case "Home":
            drawDash(); //toggleMenuItem("Contact"); // Show/hide "Contact" menu item
            break;

        case "Show All Items":
            updateAllDashItems(true);
            drawDash();
            break;
        case "Graphs":
            // drawGraphs();
            drawInitialChart();
            // let tmpGraphCtx = document.getElementById('mainCanvas');  // ctx is a canvas
            // tmpGraphCtx.style.display = 'block';

            break;
        case "Toggle Grid":
            showGrid = !showGrid;
            drawDash();
            break;

        case "Grid Code":
            copyGridCodeToClipboard();
            break;

        default:
            console.warn(`Unhandled item: ${item}`);
    }
}

// Helper function: Enable all dash items
function updateAllDashItems(enabled) {
    dash.forEach(obj => obj.enabled = enabled);
}

// Helper function: Copy Grid Code to Clipboard
function copyGridCodeToClipboard() {
    const gridTxt = dash.map(obj => 
        `updateSensorLocation(dash, '${obj.name}', ${obj.col}, ${obj.row}, ${obj.enabled});`
    ).join("\n");

    if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(gridTxt)
            .then(() => alert(`Grid code copied to clipboard:\n${gridTxt}`))
            .catch(err => console.error("Error copying text:", err));
    } else {
        console.error("Clipboard API not supported");
        alert(`Grid code (could not copy to clipboard):\n${gridTxt}`);
    }
}
</script>
</body></html>
