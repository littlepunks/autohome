<!DOCTYPE html>
<html lang="en">
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script> <!-- Include Socket.io -->

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Autohome</title>
  <link rel="stylesheet" href="styles.css"></head>
<body>

<ul class="menu" id="menubar">
   <li><a onclick="handleItemClick('Home')">Home</a></li>
    
  <li class="dropdown">
    <a href="http://192.168.68.72/autohome.html#" class="dropbtn">Other</a>
    <div class="dropdown-content" style="display: none;">
      <a href="http://192.168.68.72/autohome.html#">Webb</a>
      <a href="http://192.168.68.72/autohome.html#">Mobile</a>
      <a href="http://192.168.68.72/autohome.html#">UI/UX</a>
    </div>
  </li>
  
  <li class="dropdown">
    <a class="dropbtn">Services</a>
    <div class="dropdown-content" style="display: none;">
      <a onclick="handleItemClick('Web')">Web</a>
      <a href="http://192.168.68.72/autohome.html#">Mobile App Development</a>
      <a href="http://192.168.68.72/autohome.html#">UI/UX Design</a>
    </div>
  </li>
  
  <li>
    <a id="Dev">Settings</a>
    <div class="dropdown-content">
      <a onclick="handleItemClick('Grid Code')">Grid Code</a>
      <a onclick="handleItemClick('Toggle Grid')">Toggle Grid</a>
      <a onclick="handleItemClick('Show All Items')">Show All Items</a>
    </div>

  </li>
</ul>
<div class="canvas-container">
  <canvas id="mainCanvas" width="150" height="754"></canvas>
</div>
<div id="contextMenu" class="context-menu" style="left: 444px; top: 518px; display: block;">
  <ul>
      <li onclick="handleContextMenuClick('Hide')">Hide</li>
      <li onclick="handleContextMenuClick('Something')">Something</li>
      <li onclick="handleContextMenuClick('Else')">Else</li>
  </ul>
</div>

<script>

// ============================================================================================
//
// To do:
// - Ideally when dragging a control the rest of the screen shows other controls
// - When dragging target area should show a highlight
// - Add switches, status, plain numbers, text, clock, alarm
// - change language to 'controls'
// - Better classes and values including (x,y) (r,c)
// - Different size tiles
// - When dragging bars, they move as gauges (?!), need common draw gauge function
// - Change hard coded numbers like padding in pixels to ratios
// - Doesn't resize properly when windows is very wide
// - When resizing window the whole dash scales weirdly until you stop and do a proper refresh
// ============================================================================================



// Menu event handlers

document.body.addEventListener("mouseover", (event) => {
   const dropdown = event.target.closest(".dropdown");
   if (dropdown) {
      dropdown.querySelector(".dropdown-content").style.display = "block";
   }
});

document.body.addEventListener("mouseout", (event) => {
   const dropdown = event.target.closest(".dropdown");
   if (dropdown) {
      dropdown.querySelector(".dropdown-content").style.display = "none";
   }
});

// Get the canvas element and its 2D context, and the context menu
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const contextMenu = document.getElementById('contextMenu');
contextMenu.style.display = 'none'; // Hide the context menu after clicking

// Set height to be full screen minus the height of the menu
let menuObj = document.getElementById('menubar');
canvas.height = window.innerHeight - menuObj.offsetHeight-10;
canvas.width = (window.innerWidth > 500) ? 500 : window.innerWidth  ;

// Set up canvas style settings
ctx.shadowColor = 'rgba(0, 0, 20, 0.5)';  // Shadow color with transparency
ctx.shadowBlur = 10;                      // Shadow blur radius
ctx.shadowOffsetX = 5;                    // Horizontal shadow offset
ctx.shadowOffsetY = 5;                    // Vertical shadow offset

const colGaugeBkgnd = '#907010';          // Dark orange/yellow
const colGaugeColor = '#d0b020';          // Light orange/yellow
const colGrid       = '#808080';          // Medium grey
const colBackground = '#204060';          // Medium blue

let showGrid = true;

const PI  = Math.PI;
const PI2 = 2 * Math.PI;

// Used for detecting touch events (right click) on a mobile device
let touchTimer = null;

// Grid settings
const cols = 4;
const rows = 5;
let margin = canvas.width /(cols*2);   // margin is half the column width
let colWidth = canvas.width / cols;
const rowHeight = canvas.height / rows; // Will this need adjusting on resize?

// Top left item is at 0,0
// colWidth = 125 

// Convert an X or Y coordinate to a row or column
function xy2rc(xy) {
  return (xy < 0) ? 1 : (Math.floor(xy/colWidth) + 1);
}

// Convert a row or column to an X or Y coordinate
function rc2xy(rc) {
  return (rc <= 0) ? 0 : ((rc-1) * colWidth);
}

// Connect to the Socket.io server
const socket = io();

// Process a sensor message from the server
socket.on('SMv2', (arg) => {
 console.log(arg);
  
  const msg = typeof arg === 'string' ? JSON.parse(arg) : arg;
  updateSensor(msg.name, msg.value);

  drawDash();
  }
);

// Update display info:
function updateSensor(name, value) {
  for (let item of dash) {
      if (item.name === name) {
        item.value = value;
        break; // Stop the loop once the name is found
      }
  }
}

let dash = []; // Initialize the dash array

// Request an initial sensor list from the server
socket.emit('ClientMsg', 'init');

// Process the initial sensor list from the server
socket.on('sensors', (arg) => {
  dash = JSON.parse(arg);
  dash.forEach(obj => {  //Set some initial values that are client specific
    obj.x = 0;
    obj.y = 0;
    obj.col = 0
    obj.row = 0;
    obj.enabled = false;
    obj.min ??= 0; // Default min to 0 if not provided
    obj.max ??= 0;
    obj.suffix ??= ''; // Default suffix to empty string if not provided    
  });
  console.log(dash);

  // Update display info:
  function updateSensorLocation(data, name, col, row, enabled) {
    for (let item of data) {
        if (item.name === name) {
          item.col = col;
          item.row = row;
          item.enabled = enabled;
          item.x = (item.col-1) * colWidth;
          item.y = (item.row-1) * colWidth;

          break; // Stop the loop once the name is found
        }
    }
  }

  // Set the initial locations of the sensors
  updateSensorLocation(dash, 'Bedroom', 1, 1, true);
  updateSensorLocation(dash, 'Balcony', 2, 1, true);
  updateSensorLocation(dash, 'Freezer', 3, 1, true);
  updateSensorLocation(dash, 'Laundry', 4, 1, true);

  updateSensorLocation(dash, 'Tom', 1, 2, true);
  updateSensorLocation(dash, 'Speed', 2, 2, true);
  updateSensorLocation(dash, 'Humidity', 3, 2, true);
  updateSensorLocation(dash, 'Pressure', 4, 2, true);

  updateSensorLocation(dash, 'Sunrise', 1, 3, true);
  updateSensorLocation(dash, 'Sunset', 2, 3, true);
  updateSensorLocation(dash, 'Web Temp', 3, 3, true);
  
  updateSensorLocation(dash, 'W Desc', 1, 4, true);
  updateSensorLocation(dash, 'W Main', 2, 4, true);
  updateSensorLocation(dash, 'Hall', 3, 4, true);
  updateSensorLocation(dash, 'Door', 4, 4, true);

  drawDash();

});


// Helper functions
// ----------------------------------------------------------------------
// Draw grid
function drawGrid() {
    if (showGrid) {
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 0;

        ctx.strokeStyle = colGrid;
        ctx.lineWidth = 1;
        ctx.beginPath()

        // Draw vertical lines
        for (let i=1; i < cols; i++) {
            ctx.moveTo(colWidth*i,0);
            ctx.lineTo(colWidth*i,canvas.height);
        }

        // Draw horizontal lines
        for (let j=1; j < rows; j++) {
            ctx.moveTo(0, colWidth*j);
            ctx.lineTo(canvas.width, colWidth*j);
        }
        ctx.stroke();

        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.shadowBlur = 10;


    }
}

function drawDash() {
  setBackgroundColor(colBackground);

  drawGrid();

  dash.forEach(obj => {
    if (obj.enabled) drawDashObj(obj);
  })
}

// Need to add MAX/MIN to the settings for gauges
function drawDashObj(dashObj, overrides = {}) {
  if (!dashObj.enabled) return;

  const drawFunctions = {
    'GAU': drawGauge,
    'STA': drawStatus,
    'bar-v': drawBarV,
    'bar-h': drawBarH
    }
  const drawFunction = drawFunctions[dashObj.control];
  if (drawFunction) {

    if (overrides.shadow) {
      ctx.shadowColor = 'rgba(0, 0, 0, 1)';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 10;
      ctx.shadowOffsetY = 10;
    } else {
      ctx.shadowColor = 'rgba(0, 0, 20, 0.5)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 5;
      ctx.shadowOffsetY = 5;
    }
    drawFunction(dashObj, overrides);
    }
}

// DRAW GAUGE

function drawGauge(g, opts) {
  const thickness = 14; // Bigger numbers make it thinner

  // Determine X/Y coordinates
  let cx = opts?.x ?? margin + (g.col - 1) * colWidth;
  let cy = opts?.y ?? margin + (g.row - 1) * colWidth;

  if (opts && Object.keys(opts).length > 0) {
      drawGrid();
  }

  // Determine fill color based on contact_status
  const colorMap = {
      1: "darkorange",
      2: "red"
  };
  const fillColor = colorMap[g.contact_status] || "darkgreen";
  drawArc(cx, cy, canvas.width / (cols * 2.8), fillColor);

  // Draw gauge background
  drawArc(cx, cy, canvas.width / (cols * 2.6), colGaugeBkgnd, true, canvas.width / (thickness * cols));

  // Draw gauge value arc
  const angle = (2 * (g.value - g.min) / (g.max - g.min)) * Math.PI;
  ctx.beginPath();
  ctx.arc(cx, cy, canvas.width / (cols * 2.6), -Math.PI / 2, -Math.PI / 2 + angle);
  ctx.strokeStyle = colGaugeColor;
  ctx.lineWidth = canvas.width / (thickness * cols);
  ctx.stroke();

  // Draw labels
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${canvas.width / (11 * cols)}px Arial`;
  ctx.fillText(g.name, cx, cy - margin * 0.3);

  // Scale font size dynamically based on text length
  const gaugeText = `${g.value}${g.suffix ?? ''}`;
  ctx.font = `${Math.max(12, canvas.width / (cols * (gaugeText.length * 5)))}px Arial`;

  // Set the text color based on alarm state
  ctx.fillStyle = g.alarmState === 1 ? 'orange' : g.alarmState === 2 ? 'red' : 'white';
  ctx.fillText(gaugeText, cx, cy + margin * 0.25);
}


function drawArc(x, y, radius, style, isStroke = false, lineWidth = 1) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    if (isStroke) {
        ctx.strokeStyle = style;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
    } else {
        ctx.fillStyle = style;
        ctx.fill();
    }
}

// DRAW STATUS
function drawStatus(g, opts) {
    const thickness = 14; // Bigger numbers make it thinner

    // See if x/y coords are included and if so, respect those, otherwise x/y will be based on col/row as normal
    let cx = 0;
    let cy = 0;

    if (opts && Object.keys(opts).length > 0) {
        drawGrid();
    }
    cx = opts?.x ?? margin + (g.col - 1) * colWidth;
    cy = opts?.y ?? margin + (g.row - 1) * colWidth;

    // Determine the fill color based on contact_status
    // Draw orange/red background if in alarm states 1 or 2 (0 is no alarm)
    const colorMap = {
      1: "darkorange",
      2: "red"
    };
    const fillColor = colorMap[g.contact_status] || "darkgreen";

    drawArc(cx, cy, canvas.width / (cols * 2.8), fillColor);
    drawArc(cx, cy, canvas.width / (cols * 2.6), colGaugeBkgnd, true, canvas.width / (thickness * cols));
    drawArc(cx, cy + margin * 0.25, canvas.width / (cols * 6), colGaugeColor, true, canvas.width / (thickness * cols * 1.8));
    drawArc(cx, cy + margin * 0.25, canvas.width / (cols * 8), g.status == '1' ? 'green' : 'red');

    // Draw labels
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.font = `${canvas.width / (11 * cols)}px Arial`;
    ctx.fillText(g.name, cx, cy - margin * 0.3);

}

// Function to simplify line drawing
function drawLine(x1, y1, x2, y2, style, width) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = style;
    ctx.lineWidth = width;
    ctx.stroke();
}

function drawBarV(b, opts) {
    // Determine X/Y coordinates
    let bx = opts?.x ?? margin + (b.col - 1) * colWidth;
    let by = opts?.y ?? margin + (b.row - 1) * colWidth;

    if (opts && Object.keys(opts).length > 0) {
        drawGrid();
    }

    // Draw bar background
    const lineWidth = canvas.width / (8 * cols);
    drawLine(bx, by - (0.8 * margin), bx, by + (0.8 * margin), colGaugeBkgnd, lineWidth);

    // Draw bar value
    const valueHeight = (0.8 * colWidth * (b.value - b.min) / (b.max - b.min));
    drawLine(bx, by + (0.8 * margin), bx, by + (0.8 * margin) - valueHeight, colGaugeColor, lineWidth);

    // Draw labels - value, max, and min
    ctx.font = `${canvas.width / (6 * cols)}px Arial`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'right';
    ctx.fillText(b.value, bx - 15, by + 8);

    ctx.font = `${canvas.width / (12 * cols)}px Arial`;
    ctx.textAlign = 'left';
    ctx.fillText(b.max, bx + 15, by - (0.8 * margin) + 10);
    ctx.fillText(b.min, bx + 15, by + (0.8 * margin) - 2);
}

function drawBarH(b, opts) {
    // Determine X/Y coordinates
    let bx = opts?.x ?? margin + (b.col - 1) * colWidth;
    let by = opts?.y ?? margin + (b.row - 1) * colWidth;

    if (opts && Object.keys(opts).length > 0) {
        drawGrid();
    }

    // Draw bar background
    const lineWidth = canvas.width / (8 * cols);
    drawLine(bx - (0.8 * margin), by, bx + (0.8 * margin), by, colGaugeBkgnd, lineWidth);

    // Draw bar value
    const valueWidth = (0.8 * colWidth * (b.value - b.min) / (b.max - b.min));
    drawLine(bx - (0.8 * margin), by, bx - (0.8 * margin) + valueWidth, by, colGaugeColor, lineWidth);

    // Draw labels - value, min, and max
    ctx.font = `${canvas.width / (6 * cols)}px Arial`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(b.value, bx, by - 18);

    ctx.font = `${canvas.width / (12 * cols)}px Arial`;
    ctx.textAlign = 'left';
    ctx.fillText(b.min, bx - (0.8 * margin), by + 22);
    ctx.textAlign = 'right';
    ctx.fillText(b.max, bx + (0.8 * margin), by + 22);
}


// Change the canvas background color
function setBackgroundColor(color) {
    // Save the current transformation matrix
    ctx.save();

    // Reset the canvas transformation matrix
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Restore the saved transformation matrix
    ctx.restore();

    // Set the new background color
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// Toggle menu item visibility
function toggleMenuItem(itemId) {
    var item = document.getElementById(itemId);
    if (item) {
      item.style.display = (item.style.display == 'none') ? 'block' : 'none';
    }
}

// Set menu item visibility
function set(itemId, show) {
    var item = document.getElementById(itemId);
    if (item) {
        item.style.display = show ? 'block' : 'none';
    }
}


// Draw everything
drawDash();
let resizeTimer = null; // Timer for resize event debouncing
window.addEventListener('resize', () => {
    clearTimeout(resizeTimer); // Clear the previous timer
    resizeTimer = setTimeout(() => {
        // Resize the canvas and redraw
        canvas.height = window.innerHeight - menuObj.offsetHeight-10;
        canvas.width = (window.innerWidth > 500) ? 500 : window.innerWidth  ;
        margin = canvas.width /(cols*2);   // margin is half the column width

        colWidth = canvas.width/cols; // How far apart cells are   500 wide / 4 cols = 125 pxls
        canvas.style.width = window.innerWidth;
        canvas.style.height = window.innerHeight;

        // Optionally, redraw your canvas content here
        setBackgroundColor(colBackground);
        drawDash();
    }, 100); // Adjust the delay as needed (e.g., 100ms)

});

canvas.addEventListener("click", (event) => {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const col = Math.floor(x / colWidth) + 1;
    const row = Math.floor(y / rowHeight) + 1;
    //console.log(`Clicked at Row: ${row}, Column: ${col}`);

    // Check if a sensor exists at the clicked location
    const ctrl = dash.find(obj => obj.col === col && obj.row === row);

    if (ctrl) {

      function formattimeStamp(timeStamp) {
        const date = new Date(timeStamp); //
        return date.toLocaleString('en-NZ'); // Returns a formatted date/time
      }

      // console.log(`Clicked on sensor: ${ctrl.name} (Row: ${row}, Column: ${col})`);
      // Show popup
      const popup = document.createElement("div");
      popup.innerText =
       `ID: ${ctrl.id}
        Name: ${ctrl.name}
        Value: ${ctrl.value}${ctrl.suffix ?? ''}
        Contact Status: ${ctrl.contact_status === '0' ? 'OK (0)' : ctrl.contact_status === '1' ? 'Late (1)' :  ctrl.contact_status === '2' ? 'Missing (2)' : 'Undefined'}
        Last Contact: ${formattimeStamp(ctrl.updated)}
        AlarmState: ${ctrl.alarmState}
        Min: ${ctrl.min}
        Max: ${ctrl.max}
        Warning Threshold: ${ctrl.warningThreshold}
        Alarm Threshold: ${ctrl.alarmThreshold}
        Col: ${ctrl.col}
        Row: ${ctrl.row}
        Enabled: ${ctrl.enabled}
        Control Type: ${ctrl.control}`;
      popup.style.position = "absolute";
      popup.style.backgroundColor = "rgba(0,0,10,0.9)";
      popup.style.color = "white";
      popup.style.border = "1px solid white";
      popup.style.padding = "10px";
      popup.style.zIndex = "1000";
      popup.style.top = `${event.clientY}px`;
      popup.style.left = `${event.clientX}px`;
      popup.style.fontSize = "12px";
      document.body.appendChild(popup);

      // Remove popup after a delay
      setTimeout(() => {
          popup.remove();
      }, 10000);
    } else {
      //console.log(`Clicked on blank space (Row: ${row}, Column: ${col})`);
    }


});

// ---------------------------------------------------------------------------
//let selectedObject = null;
let offsetX, offsetY;
//let clickX, clickY;

//         // Show popup
//         const popup = document.createElement("div");
//         popup.innerText = `Control: ${controlNameOrNumber}`;
//         popup.style.position = "absolute";
//         popup.style.backgroundColor = "rgba(0,0,0,0.7)";
//         popup.style.color = "white";
//         popup.style.border = "1px solid white";
//         popup.style.padding = "10px";
//         popup.style.zIndex = "1000";
//         popup.style.top = `${event.clientY}px`;
//         popup.style.left = `${event.clientX}px`;
//         document.body.appendChild(popup);

//         // Remove popup after a delay
//         setTimeout(() => {
//             popup.remove();
//         }, 2000);
//     }
// });

// Menu item click handler
// This function is called when a menu item is clicked
function handleItemClick(item) {
    if (!item) return;

    switch (item) {
        case "Web":
            window.alert("You are doing the Web");
            break;

        case "Home":
            toggleMenuItem("Contact"); // Show/hide "Contact" menu item
            break;

        case "Show All Items":
            updateAllDashItems(true);
            drawDash();
            break;

        case "Toggle Grid":
            showGrid = !showGrid;
            drawDash();
            break;

        case "Grid Code":
            copyGridCodeToClipboard();
            break;

        default:
            console.warn(`Unhandled item: ${item}`);
    }
}

// Helper function: Enable all dash items
function updateAllDashItems(enabled) {
    dash.forEach(obj => obj.enabled = enabled);
}

// Helper function: Copy Grid Code to Clipboard
function copyGridCodeToClipboard() {
    const gridTxt = dash.map(obj => 
        `updateSensorLocation(dash, '${obj.name}', ${obj.col}, ${obj.row}, ${obj.enabled});`
    ).join("\n");

    if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(gridTxt)
            .then(() => alert(`Grid code copied to clipboard:\n${gridTxt}`))
            .catch(err => console.error("Error copying text:", err));
    } else {
        console.error("Clipboard API not supported");
        alert(`Grid code (could not copy to clipboard):\n${gridTxt}`);
    }
}
</script>
</body></html>